/*
 * generated by Xtext
 */
package org.xtext.example.statemachine.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.xtext.example.statemachine.statemachine.Statemachine

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class StatemachineGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for(e: resource.allContents.toIterable.filter(Statemachine)){
			fsa.generateFile( e.name.toString() + ".h", e.compileH )
			fsa.generateFile( e.name.toString() + ".c", e.compileC )
		}
	}
	
	def compileH(Statemachine stm)'''
		// definition of states
		typedef enum {
			«FOR s:stm.states»
				«s.name»«IF s != stm.states.last»,«ENDIF»
			«ENDFOR»
		} state_t;
		
		// definition of events
		typedef enum {
			«FOR e:stm.events»
				«e.name»«IF e != stm.events.last»,«ENDIF»
			«ENDFOR»
		} event_t;
		
		// function prototypes
		void init();
		int next( event_t e );
		state_t current_state();
		
		// state entering functions
		«FOR s:stm.states»
			void enter_«s.name.toString»( event_t e );
		«ENDFOR»
		
		// state exiting functions
		«FOR s:stm.states»
			void exit_«s.name.toString»( event_t e );
		«ENDFOR»
		
		// transition functions
		«FOR t:stm.transitions»
			void trans_«t.from.name.toString»_«t.event.name.toString»_«t.to.name.toString»();
		«ENDFOR»
	'''
	
	def compileC(Statemachine stm)'''
		#include "«stm.name.toString».h"
		
		static state_t state;
		
		typedef struct {
			state_t state;
			void (*enter_func)( event_t );
			void (*exir_func)( event_t );
			
		} state_info_t;
		
		static state_info_t state_info_table[] = {
			«FOR s:stm.states»
				{ «s.name.toString», enter_«s.name.toString», exit_«s.name.toString» }, 
			«ENDFOR»
		};
		
		typedef struct {
			state_t from;
			event_t event;
			state_t to;
			void (*trans_func)();
		} transition_t;
		
		static transition_t transition_table[] = {
			«FOR t:stm.transitions»
				{ «t.from.name.toString», «t.event.name.toString», «t.to.name.toString», trans_«t.from.name.toString»_«t.event.name.toString»_«t.to.name.toString» },
			«ENDFOR»
		};
		
		void init()
		{
			state = «stm.initialiState.name.toString»;
		}
		
		int next( event_t e )
		{
			for( int i = 0; i < sizeof(transition_table)/sizeof(transition_table[0]; i++ ){
				if( (transition_table[i].from == _state) && (transition_table[i].event == e) ){
					for( int idx_state= 0; idx_state < sizeof(state_info_t)/sizeof(state_info_t[0]); idx_state++ ){
						if( state_info_t[idx_state].state == transition_table[i].from ){
							(*(state_info_t[idx_state].exit_func))( e );
							break;
						}
					}
					state = transition_table[i].to;
					(*(transition_table[i].trans_func))();
					for( int idx_state= 0; idx_state < sizeof(state_info_t)/sizeof(state_info_t[0]); idx_state++ ){
						if( state_info_t[idx_state].state == transition_table[i].to ){
							(*(state_info_t[idx_state].exit_func))( e );
							break;
						}
					}
					return 1;
				}
			}
			return 0;
		}
		
		state_t current_state()
		{
			return state;
		}
	'''
}
